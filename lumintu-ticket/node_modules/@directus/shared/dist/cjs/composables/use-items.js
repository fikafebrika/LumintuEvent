"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useItems = void 0;
const use_system_1 = require("./use-system");
const use_collection_1 = require("./use-collection");
const utils_1 = require("../utils");
const lodash_1 = require("lodash");
const vue_1 = require("vue");
function useItems(collection, query, fetchOnInit = true) {
    const api = (0, use_system_1.useApi)();
    const { primaryKeyField, sortField } = (0, use_collection_1.useCollection)(collection);
    let loadingTimeout = null;
    const { limit, fields, sort, page, filters, searchQuery } = query;
    const endpoint = (0, vue_1.computed)(() => {
        if (!collection.value)
            return null;
        return collection.value.startsWith('directus_')
            ? `/${collection.value.substring(9)}`
            : `/items/${collection.value}`;
    });
    const items = (0, vue_1.ref)([]);
    const loading = (0, vue_1.ref)(false);
    const error = (0, vue_1.ref)(null);
    const itemCount = (0, vue_1.ref)(null);
    const totalCount = (0, vue_1.ref)(null);
    const totalPages = (0, vue_1.computed)(() => {
        if (itemCount.value === null)
            return 1;
        if (itemCount.value < limit.value)
            return 1;
        return Math.ceil(itemCount.value / limit.value);
    });
    if (fetchOnInit) {
        getItems();
    }
    (0, vue_1.watch)(collection, async (after, before) => {
        if (!before || (0, lodash_1.isEqual)(after, before)) {
            return;
        }
        // Waiting for the tick here makes sure the query have been adjusted for the new
        // collection
        await (0, vue_1.nextTick)();
        reset();
        getItems();
    }, { immediate: fetchOnInit });
    (0, vue_1.watch)([page, fields], async (after, before) => {
        if (!before || (0, lodash_1.isEqual)(after, before)) {
            return;
        }
        await (0, vue_1.nextTick)();
        if (loading.value === false) {
            getItems();
        }
    });
    (0, vue_1.watch)(sort, async (after, before) => {
        if (!before || (0, lodash_1.isEqual)(after, before)) {
            return;
        }
        // When all items are on page, we only sort locally
        const hasAllItems = limit.value > (itemCount.value || 0);
        if (hasAllItems) {
            sortItems(after);
            return;
        }
        await (0, vue_1.nextTick)();
        if (loading.value === false) {
            getItems();
        }
    });
    (0, vue_1.watch)([filters, limit], async (after, before) => {
        if (!before || (0, lodash_1.isEqual)(after, before)) {
            return;
        }
        page.value = 1;
        await (0, vue_1.nextTick)();
        if (loading.value === false) {
            getItems();
        }
    });
    (0, vue_1.watch)(searchQuery, (0, lodash_1.throttle)(async (after, before) => {
        if ((0, lodash_1.isEqual)(after, before)) {
            return;
        }
        page.value = 1;
        await (0, vue_1.nextTick)();
        if (loading.value === false) {
            getItems();
        }
    }, 500, { trailing: true }));
    return { itemCount, totalCount, items, totalPages, loading, error, changeManualSort, getItems };
    async function getItems() {
        if (loadingTimeout || !endpoint.value)
            return;
        error.value = null;
        loadingTimeout = window.setTimeout(() => {
            loading.value = true;
        }, 250);
        let fieldsToFetch = [...fields.value];
        // Make sure the primary key is always fetched
        if (fields.value.includes('*') === false &&
            primaryKeyField.value &&
            fieldsToFetch.includes(primaryKeyField.value.field) === false) {
            fieldsToFetch.push(primaryKeyField.value.field);
        }
        // Make sure all fields that are used to filter are fetched
        if (fields.value.includes('*') === false) {
            filters.value.forEach((filter) => {
                if (fieldsToFetch.includes(filter.field) === false) {
                    fieldsToFetch.push(filter.field);
                }
            });
        }
        // Make sure that the field we're sorting on is fetched
        if (fields.value.includes('*') === false && sortField.value && sort.value) {
            const sortFieldKey = sort.value.startsWith('-') ? sort.value.substring(1) : sort.value;
            if (fieldsToFetch.includes(sortFieldKey) === false) {
                fieldsToFetch.push(sortFieldKey);
            }
        }
        // Filter out fake internal columns. This is (among other things) for a fake $thumbnail m2o field
        // on directus_files
        fieldsToFetch = fieldsToFetch.filter((field) => field.startsWith('$') === false);
        try {
            const response = await api.get(endpoint.value, {
                params: {
                    limit: limit.value,
                    fields: fieldsToFetch,
                    sort: sort.value,
                    page: page.value,
                    search: searchQuery.value,
                    ...(0, utils_1.filtersToQuery)(filters.value),
                },
            });
            let fetchedItems = response.data.data;
            /**
             * @NOTE
             *
             * This is used in conjunction with the fake field in /src/stores/fields/fields.ts to be
             * able to render out the directus_files collection (file library) using regular layouts
             *
             * Layouts expect the file to be a m2o of a `file` type, however, directus_files is the
             * only collection that doesn't have this (obviously). This fake $thumbnail field is used to
             * pretend there is a file m2o, so we can use the regular layout logic for files as well
             */
            if (collection.value === 'directus_files') {
                fetchedItems = fetchedItems.map((file) => ({
                    ...file,
                    $thumbnail: file,
                }));
            }
            items.value = fetchedItems;
            itemCount.value = response.data.data.length;
            if (fetchedItems.length === 0 && page.value !== 1) {
                page.value = 1;
            }
            getItemCount();
        }
        catch (err) {
            error.value = err;
        }
        finally {
            clearTimeout(loadingTimeout);
            loadingTimeout = null;
            loading.value = false;
        }
    }
    async function getItemCount() {
        if (!primaryKeyField.value || !endpoint.value)
            return;
        const response = await api.get(endpoint.value, {
            params: {
                limit: 0,
                fields: primaryKeyField.value.field,
                meta: ['filter_count', 'total_count'],
                search: searchQuery.value,
                ...(0, utils_1.filtersToQuery)(filters.value),
            },
        });
        totalCount.value = response.data.meta.total_count;
        itemCount.value = response.data.meta.filter_count;
    }
    function reset() {
        items.value = [];
        totalCount.value = null;
        itemCount.value = null;
    }
    function sortItems(sortBy) {
        const field = sortBy.startsWith('-') ? sortBy.substring(1) : sortBy;
        const descending = sortBy.startsWith('-');
        items.value = (0, lodash_1.orderBy)(items.value, [field], [descending ? 'desc' : 'asc']);
    }
    async function changeManualSort({ item, to }) {
        var _a;
        const pk = (_a = primaryKeyField.value) === null || _a === void 0 ? void 0 : _a.field;
        if (!pk)
            return;
        const fromIndex = items.value.findIndex((existing) => existing[pk] === item);
        const toIndex = items.value.findIndex((existing) => existing[pk] === to);
        items.value = (0, utils_1.moveInArray)(items.value, fromIndex, toIndex);
        const endpoint = (0, vue_1.computed)(() => `/utils/sort/${collection.value}`);
        await api.post(endpoint.value, { item, to });
    }
}
exports.useItems = useItems;
